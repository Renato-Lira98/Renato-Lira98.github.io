:source-highlighter: rouge
= Processamento Digital de Imagens
Renato Emanuel Medeiros de Lira - renato.lira.016@ufrn.edu.br
:toc: left

== 1 Manipulando pixels em uma imagem

Manipular pixels em uma imagem envolve a capacidade de alterar individualmente os elementos de cor que compõem a imagem. Cada pixel contém informações sobre sua cor específica, como vermelho, verde e azul (RGB), além de valores de transparência em alguns casos. Ao manipular os pixels, é possível realizar uma variedade de transformações na imagem, como ajustar o brilho, a saturação, o contraste, aplicar filtros, redimensionar ou recortar. Essas manipulações permitem corrigir imperfeições, realçar detalhes, criar efeitos especiais, entre outras possibilidades. A manipulação de pixels é uma técnica fundamental em áreas como processamento de imagem, design gráfico, edição de fotos e criação de arte digital. Com a ajuda de bibliotecas de processamento de imagem, é possível acessar e modificar os valores dos pixels em uma imagem, abrindo caminho para inúmeras possibilidades criativas e práticas.

=== 1.1 Exercicio 1.1 - Filtro Negativo (regions.cpp)

O filtro negativo é um mecanismo que busca eliminar conteúdos indesejados, inapropriados ou prejudiciais por meio da aplicação de técnicas de análise e restrição. Ele é amplamente utilizado em diversas áreas, como tecnologia da informação, mídias sociais e segurança, visando proteger os usuários e garantir a qualidade do conteúdo. No entanto, é necessário ter cautela para evitar restrições excessivas e preservar a liberdade de expressão. 

Com isso, crie um programa chamado <<exa_regions>> com base no código de exemplo "pixels.cpp". O programa deve pedir ao usuário as coordenadas de dois pontos, P1 e P2, que estão dentro dos limites do tamanho da imagem. Em seguida, ele deve exibir a imagem fornecida, mas com a região definida pelo retângulo formado pelos pontos P1 e P2 exibindo o negativo da imagem nessa área específica. Esse efeito produzirá uma região destacada com cores invertidas em relação ao restante da imagem.

==== 1.1.1 Código e Resultado.

[[exa_regions, regions]]
[source,cpp]
.regions.cpp
----
include::regions.cpp[]
----

Abaixo temos a imagem original <<fig_biel>> e em seguida a imagem resultante do código <<fig_regions>>. As Coordenadas escolhidas foram P1 (90, 180) e P2 (90, 180).

[[fig_biel, biel]]
.Imagem original
image::biel.png[title="Imagem original"]

[[fig_regions, regions]]
.Saída do programa regions
image::Regions.png[title="Saída do programa regions.cpp"]

=== 1.2 Exercicio 1.2 - Troca Regiões (trocaregioes.cpp)

Desenvolva um programa chamado <<trocaregioes.cpp>> com base no código de exemplo "pixels.cpp". O programa deve trocar os quadrantes diagonais na imagem. Para realizar essa troca, utilize a classe "Mat" e seus construtores para criar as regiões que serão intercambiadas. Ao executar o programa, a imagem exibida terá os quadrantes diagonais trocados.

==== 1.1.2 Código e Resultado.

[[exa_trocaregioes, trocaregioes]]
[source,cpp]
.trocaregioes.cpp
----
include::trocaregioes.cpp[]
----

Abaixo temos a imagem original <<fig_biel>> e em seguida a imagem resultante do código <<fig_trocaregioes>>, na qual os quadrantes foram trocados de lugar.

[[fig_trocaregioes, trocaregioes]]
.Saída do programa trocaregioes.cpp
image::trocaregioes.png[title="Saída do programa trocaregioes.cpp"]

== 2. Serialização de dados em ponto flutuante via FileStorage

A serialização de dados em ponto flutuante usando o FileStorage envolve a gravação e leitura de valores numéricos em formato de ponto flutuante em um arquivo estruturado. Ao utilizar a classe FileStorage, é possível gravar os dados em um formato como YAML ou XML, permitindo a preservação da precisão fracionária. A leitura dos dados serializados também é facilitada pela classe FileStorage, tornando possível acessar e utilizar os valores gravados posteriormente. Esse processo é especialmente útil em cenários onde é necessário armazenar e recuperar informações numéricas precisas, como em aplicações científicas, processamento de imagens e simulações.

=== 2.1. Exercicio 2 - filestorage.cpp

Utilizando o programa "filestorage.cpp" como base, crie um novo programa que gere uma imagem de 256x256 pixels contendo uma senóide horizontal com 4 períodos e amplitude de 127, semelhante à figura apresentada na <<filestorage_exemplo>>. Grave a imagem em formato PNG e em formato YML. Em seguida, compare os arquivos gerados, extraindo uma linha de cada imagem gravada e calculando a diferença entre elas. Trace um gráfico dessa diferença ao longo da linha correspondente nas imagens. Observe os resultados e faça as observações relevantes.

[[fig_filestorage_exemplo, filestorage]]
.Exemplo 
image::senoide.png[title="Imagem de uma senóide horizontal com 8 periodos"]


==== 2.1.1. Código e Resultado.

[[exa_filestorage, filestorage]]
[source,cpp]
.filestorage.cpp
----
include::filestorage.cpp[]
----

Abaixo temos a imagem resultante do código <<fig_filestorage>>, na qual é representado uma senoide horizontal com 4 periodos e amplitude de 127. A imagem é semelhante a figura <<filestorage_exemplo>> usada como exemplo.

[[fig_filestorage, filestorage]]
.Saída do programa filestorage.cpp
image::senoide.png[title="Saída do programa filestorage.cpp"]

== 3. Decomposição de imagens em planos de bits

A decomposição de imagens em planos de bits é um processo onde uma imagem é separada em camadas binárias, cada uma representando um plano de bits específico. Isso permite analisar e manipular individualmente cada componente da imagem, seja em escala de cinza ou em cores, como vermelho, verde e azul. Essa técnica é útil em diversas aplicações, como processamento de imagem, análise de padrões e compressão de dados, possibilitando identificar características específicas e realizar manipulações precisas na intensidade de cor de cada pixel.

=== 3.1. Exercicio 3 -  esteg-encode.cpp

Escreva um programa que seja capaz de recuperar uma imagem codificada resultante de esteganografia. No processo de recuperação, os bits menos significativos dos pixels da imagem fornecida devem ser utilizados para compor os bits mais significativos dos pixels da imagem recuperada. O programa deve receber como parâmetro de linha de comando o nome do arquivo da imagem resultante da esteganografia

==== 3.1.1. Código e Resultado.

[[exa_esteg, esteg]]
[source,cpp]
.esteg.cpp
----
include::esteg.cpp[]
----

Esse programa recupera a imagem codificada a partir dos bits menos significativos dos pixels da imagem esteganografada fornecida. Os bits 6 e 7 dos canais de cor de cada pixel são zerados para compor os bits mais significativos da imagem recuperada. Abaixo temos a imagem Decodificada <<fig_imagemDecodificada>>, a imagem escondida <<fig_imagemEscondida>> e a imagem portadora <<fig_imagemPortadora>>, todas sendo saída do código <<exa_esteg>>.

[[fig_imagemDecodificada, imagemDecodificada]]
.Saída do programa esteg.cpp
image::imagemDecodificada.png[title="Saída do programa esteg.cpp, imagem Decodificada"]

[[fig_imagemPortadora, imagemPortadora]]
.Saída do programa esteg.cpp
image::imagemPortadora.png[title="Saída do programa esteg.cpp, imagem Portadora"]

[[fig_imagemEscondida, imagemEscondida]]
.Saída do programa esteg.cpp
image::imagemEscondida.png[title="Saída do programa esteg.cpp, imagem Escondida"]


== 4. Preenchendo regiões

Uma tarefa comum em processamento de imagens e visão computacional é contar a quantidade de objetos em uma cena. Para isso, é necessário identificar os aglomerados de pixels associados a cada objeto. Geralmente, trabalha-se com imagens binárias, em que cada pixel tem o valor 0 para o fundo da imagem e 255 para os objetos. Cada aglomerado de pixels é considerado um objeto separado, e esse processo é amplamente utilizado para contagem de objetos em imagens.

=== 4.1. Exercicio 4 - labeling.cpp

O programa "labeling.cpp" apresenta uma limitação quando há mais de 255 objetos na cena devido à utilização de pixels de 8 bits para rotular os objetos. Para solucionar esse problema, é necessário utilizar uma estrutura de dados com maior capacidade de armazenamento, como uma matriz de inteiros de 32 bits. Além disso, é possível aprimorar o algoritmo de contagem para identificar regiões com ou sem buracos internos, removendo os objetos que tocam as bordas da imagem e contando separadamente os buracos internos de cada objeto identificado.

==== 4.1.1. Código e Resultado.

[[exa_labeling, labeling]]
[source,cpp]
.labeling.cpp
----
include::labeling.cpp[]
----

O código <<exa_labeling>> está contando certo o número de bolhas com buracos, mas parece que houve um problema na lógica utilizada para identificar as bolhas sem buracos. A abordagem utilizada não está correta e acabou removendo todas as bolhas sem buracos da imagem. Na imagem <<fig_labeling>>, podemos ver melhor o que aconteceu

== 5. Manipulação de histogramas


=== 5.1. Exercicio 5 -  histogram.cpp


==== 5.1.1. Código e Resultado.


== 6. Filtragem no domínio espacial I


=== 6.1. Exercicio 6 - filtroespacial.cpp 


==== 6.1.1. Código e Resultado.


== 7. Filtragem no domínio espacial II


=== 7.1. Exercicio 7 -  addweighted.cpp


==== 7.1.1. Código e Resultado.


== 8. A Tranformada Discreta de Fourier


=== 8.1. Exercicio 8 - dftimage.cpp


==== 8.1.1. Código e Resultado.

